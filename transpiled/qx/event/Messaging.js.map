{
  "version": 3,
  "sources": [
    "/home/runner/work/hkollmann.mobilegrid/hkollmann.mobilegrid/node_modules/@qooxdoo/framework/source/class/qx/event/Messaging.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "construct",
    "_listener",
    "__listenerIdCount",
    "__channelToIdMapping",
    "members",
    "on",
    "channel",
    "type",
    "handler",
    "scope",
    "_addListener",
    "onAny",
    "listeners",
    "id",
    "params",
    "param",
    "lang",
    "Type",
    "isString",
    "paramsRegexp",
    "exec",
    "push",
    "RegExp",
    "replace",
    "regExp",
    "remove",
    "listener",
    "has",
    "path",
    "Object",
    "isEmpty",
    "test",
    "emit",
    "customData",
    "_emit",
    "listenerMatchedAny",
    "_emitListeners",
    "listenerMatched",
    "info",
    "_emitRoute",
    "match",
    "value",
    "shift",
    "i",
    "length",
    "call",
    "undefined",
    "event",
    "Messaging"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Tino Butz (tbtz)\n     * Martin Wittemann (wittemann)\n\n************************************************************************ */\n\n/**\n * Define messages to react on certain channels.\n *\n * The channel names will be used in the {@link #on} method to define handlers which will\n * be called on certain channels and routes. The {@link #emit} method can be used\n * to execute a given route on a channel. {@link #onAny} defines a handler on any channel.\n *\n * *Example*\n *\n * Here is a little example of how to use the messaging.\n *\n * <pre class='javascript'>\n *   var m = new qx.event.Messaging();\n *\n *   m.on(\"get\", \"/address/{id}\", function(data) {\n *     var id = data.params.id; // 1234\n *     // do something with the id...\n *   },this);\n *\n *   m.emit(\"get\", \"/address/1234\");\n * </pre>\n */\nqx.Bootstrap.define(\"qx.event.Messaging\", {\n  construct() {\n    this._listener = {};\n    this.__listenerIdCount = 0;\n    this.__channelToIdMapping = {};\n  },\n\n  members: {\n    _listener: null,\n    __listenerIdCount: null,\n    __channelToIdMapping: null,\n\n    /**\n     * Adds a route handler for the given channel. The route is called\n     * if the {@link #emit} method finds a match.\n     *\n     * @param channel {String} The channel of the message.\n     * @param type {String|RegExp} The type, used for checking if the executed path matches.\n     * @param handler {Function} The handler to call if the route matches the executed path.\n     * @param scope {var ? null} The scope of the handler.\n     * @return {String} The id of the route used to remove the route.\n     */\n    on(channel, type, handler, scope) {\n      return this._addListener(channel, type, handler, scope);\n    },\n\n    /**\n     * Adds a handler for the \"any\" channel. The \"any\" channel is called\n     * before all other channels.\n     *\n     * @param type {String|RegExp} The route, used for checking if the executed path matches\n     * @param handler {Function} The handler to call if the route matches the executed path\n     * @param scope {var ? null} The scope of the handler.\n     * @return {String} The id of the route used to remove the route.\n     */\n    onAny(type, handler, scope) {\n      return this._addListener(\"any\", type, handler, scope);\n    },\n\n    /**\n     * Adds a listener for a certain channel.\n     *\n     * @param channel {String} The channel the route should be registered for\n     * @param type {String|RegExp} The type, used for checking if the executed path matches\n     * @param handler {Function} The handler to call if the route matches the executed path\n     * @param scope {var ? null} The scope of the handler.\n     * @return {String} The id of the route used to remove the route.\n     */\n    _addListener(channel, type, handler, scope) {\n      var listeners = (this._listener[channel] = this._listener[channel] || {});\n      var id = this.__listenerIdCount++;\n      var params = [];\n      var param = null;\n\n      // Convert the route to a regular expression.\n      if (qx.lang.Type.isString(type)) {\n        var paramsRegexp = /\\{([\\w\\d]+)\\}/g;\n\n        while ((param = paramsRegexp.exec(type)) !== null) {\n          params.push(param[1]);\n        }\n        type = new RegExp(\"^\" + type.replace(paramsRegexp, \"([^/]+)\") + \"$\");\n      }\n\n      listeners[id] = {\n        regExp: type,\n        params: params,\n        handler: handler,\n        scope: scope\n      };\n\n      this.__channelToIdMapping[id] = channel;\n      return id;\n    },\n\n    /**\n     * Removes a registered listener by the given id.\n     *\n     * @param id {String} The id of the registered listener.\n     */\n    remove(id) {\n      var channel = this.__channelToIdMapping[id];\n      var listener = this._listener[channel];\n      delete listener[id];\n      delete this.__channelToIdMapping[id];\n    },\n\n    /**\n     * Checks if a listener is registered for the given path in the given channel.\n     *\n     * @param channel {String} The channel of the message.\n     * @param path {String} The path to check.\n     * @return {Boolean} Whether a listener is registered.\n     */\n    has(channel, path) {\n      var listeners = this._listener[channel];\n      if (!listeners || qx.lang.Object.isEmpty(listeners)) {\n        return false;\n      }\n\n      for (var id in listeners) {\n        var listener = listeners[id];\n        if (listener.regExp.test(path)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Sends a message on the given channel and informs all matching route handlers.\n     *\n     * @param channel {String} The channel of the message.\n     * @param path {String} The path to execute\n     * @param params {Map} The given parameters that should be propagated\n     * @param customData {var} The given custom data that should be propagated\n     */\n    emit(channel, path, params, customData) {\n      this._emit(channel, path, params, customData);\n    },\n\n    /**\n     * Executes a certain channel with a given path. Informs all\n     * route handlers that match with the path.\n     *\n     * @param channel {String} The channel to execute.\n     * @param path {String} The path to check\n     * @param params {Map} The given parameters that should be propagated\n     * @param customData {var} The given custom data that should be propagated\n     */\n    _emit(channel, path, params, customData) {\n      var listenerMatchedAny = false;\n      var listener = this._listener[\"any\"];\n      listenerMatchedAny = this._emitListeners(\n        channel,\n        path,\n        listener,\n        params,\n        customData\n      );\n\n      var listenerMatched = false;\n      listener = this._listener[channel];\n      listenerMatched = this._emitListeners(\n        channel,\n        path,\n        listener,\n        params,\n        customData\n      );\n\n      if (!listenerMatched && !listenerMatchedAny) {\n        qx.Bootstrap.info(\"No listener found for \" + path);\n      }\n    },\n\n    /**\n     * Executes all given listener for a certain channel. Checks all listeners if they match\n     * with the given path and executes the stored handler of the matching route.\n     *\n     * @param channel {String} The channel to execute.\n     * @param path {String} The path to check\n     * @param listeners {Map[]} All routes to test and execute.\n     * @param params {Map} The given parameters that should be propagated\n     * @param customData {var} The given custom data that should be propagated\n     *\n     * @return {Boolean} Whether the route has been executed\n     */\n    _emitListeners(channel, path, listeners, params, customData) {\n      if (!listeners || qx.lang.Object.isEmpty(listeners)) {\n        return false;\n      }\n      var listenerMatched = false;\n      for (var id in listeners) {\n        var listener = listeners[id];\n        listenerMatched |= this._emitRoute(\n          channel,\n          path,\n          listener,\n          params,\n          customData\n        );\n      }\n      return listenerMatched;\n    },\n\n    /**\n     * Executes a certain listener. Checks if the listener matches the given path and\n     * executes the stored handler of the route.\n     *\n     * @param channel {String} The channel to execute.\n     * @param path {String} The path to check\n     * @param listener {Map} The route data.\n     * @param params {Map} The given parameters that should be propagated\n     * @param customData {var} The given custom data that should be propagated\n     *\n     * @return {Boolean} Whether the route has been executed\n     */\n    _emitRoute(channel, path, listener, params, customData) {\n      var match = listener.regExp.exec(path);\n      if (match) {\n        var params = params || {};\n        var param = null;\n        var value = null;\n        match.shift(); // first match is the whole path\n        for (var i = 0; i < match.length; i++) {\n          value = match[i];\n          param = listener.params[i];\n          if (param) {\n            params[param] = value;\n          } else {\n            params[i] = value;\n          }\n        }\n        listener.handler.call(listener.scope, {\n          path: path,\n          params: params,\n          customData: customData\n        });\n      }\n\n      return match != undefined;\n    }\n  }\n});\n"
  ]
}