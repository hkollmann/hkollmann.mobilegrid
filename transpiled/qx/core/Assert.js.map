{
  "version": 3,
  "sources": [
    "/home/runner/work/hkollmann.mobilegrid/hkollmann.mobilegrid/node_modules/@qooxdoo/framework/source/class/qx/core/Assert.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__logError",
    "__fail",
    "comment",
    "msgvarargs",
    "msg",
    "i",
    "l",
    "arguments",
    "length",
    "__toString",
    "undefined",
    "fullComment",
    "errorMsg",
    "Class",
    "isDefined",
    "err",
    "core",
    "AssertionError",
    "error",
    "getStackTrace",
    "Error",
    "value",
    "stringValue",
    "lang",
    "Type",
    "isArray",
    "Object",
    "toString",
    "Json",
    "stringify",
    "e",
    "assert",
    "condition",
    "fail",
    "compact",
    "assertTrue",
    "assertFalse",
    "assertEquals",
    "expected",
    "found",
    "assertNotEquals",
    "assertEqualsFloat",
    "assertNumber",
    "Number",
    "equals",
    "assertNotEqualsFloat",
    "assertIdentical",
    "assertNotIdentical",
    "assertNotUndefined",
    "assertUndefined",
    "assertNotNull",
    "assertNull",
    "assertJsonEquals",
    "assertMatch",
    "str",
    "re",
    "assertString",
    "isRegExp",
    "isString",
    "search",
    "assertArgumentsCount",
    "args",
    "minCount",
    "maxCount",
    "argCount",
    "assertEventFired",
    "obj",
    "event",
    "invokeFunc",
    "listenerFunc",
    "called",
    "listener",
    "call",
    "id",
    "addListener",
    "ex",
    "removeListenerById",
    "assertEventNotFired",
    "assertException",
    "callback",
    "exception",
    "assertInArray",
    "array",
    "indexOf",
    "assertNotInArray",
    "String",
    "format",
    "assertArrayEquals",
    "assertArray",
    "join",
    "assertKeyInMap",
    "map",
    "assertFunction",
    "isFunction",
    "assertFunctionOrAsyncFunction",
    "isFunctionOrAsyncFunction",
    "assertBoolean",
    "isBoolean",
    "isNumber",
    "isFinite",
    "assertPositiveNumber",
    "assertInteger",
    "assertPositiveInteger",
    "assertInRange",
    "min",
    "max",
    "assertObject",
    "isObject",
    "assertMap",
    "assertRegExp",
    "assertType",
    "type",
    "assertInstance",
    "clazz",
    "className",
    "classname",
    "assertInterface",
    "iface",
    "implementsInterface",
    "assertCssColor",
    "ColorUtil",
    "getByName",
    "expectedRgb",
    "stringToRgb",
    "valueRgb",
    "assertElement",
    "nodeType",
    "assertQxObject",
    "__isQxInstance",
    "assertQxWidget",
    "object",
    "constructor",
    "superclass",
    "Assert"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * A collection of assertions.\n *\n * These methods can be used to assert incoming parameters, return values, ...\n * If an assertion fails an {@link AssertionError} is thrown.\n *\n * Assertions are used in unit tests as well.\n *\n * @require(qx.lang.Type)\n * @ignore(qx.Class.*)\n */\nqx.Bootstrap.define(\"qx.core.Assert\", {\n  statics: {\n    __logError: true,\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>. An\n     * {@link AssertionError} is thrown if otherwise.\n     *\n     * @param comment {String} Message to be shown if the assertion fails. This\n     *    message is provided by the user.\n     * @param msgvarargs {var} any number of parts of a message to show if assertion\n     *                         triggers. Each will be converted to a string and all\n     *                         parts will be concatenated. E. g. instead of\n     *                         \"Got invalid value \" + this.__toString(val) + \"!!!!!\"\n     *                         use\n     *                         \"Got invalid value \", val, \"!!!!!\"\n     *                         (much better performance)\n     *\n     */\n    __fail(comment, msgvarargs) {\n      // Build up message from message varargs. It's not really important\n      // how long this takes as it is done only when assertion is triggered\n      var msg = \"\";\n      for (var i = 1, l = arguments.length; i < l; i++) {\n        msg =\n          msg +\n          this.__toString(\n            arguments[i] === undefined ? \"'undefined'\" : arguments[i]\n          );\n      }\n\n      var fullComment = \"\";\n      if (msg) {\n        fullComment = comment + \": \" + msg;\n      } else {\n        fullComment = comment;\n      }\n      var errorMsg = \"Assertion error! \" + fullComment;\n\n      if (qx.Class && qx.Class.isDefined(\"qx.core.AssertionError\")) {\n        var err = new qx.core.AssertionError(comment, msg);\n        if (this.__logError) {\n          qx.Bootstrap.error(\n            errorMsg + \"\\n Stack trace: \\n\" + err.getStackTrace()\n          );\n        }\n        throw err;\n      } else {\n        if (this.__logError) {\n          qx.Bootstrap.error(errorMsg);\n        }\n        throw new Error(errorMsg);\n      }\n    },\n\n    /**\n     * Convert an unknown value to a string to display in error messages\n     *\n     * @param value {var} any value\n     * @return {String} a string representation of the value\n     */\n    __toString(value) {\n      var stringValue;\n\n      if (value === null) {\n        stringValue = \"null\";\n      } else if (qx.lang.Type.isArray(value) && value.length > 10) {\n        stringValue = \"Array[\" + value.length + \"]\";\n      } else if (value instanceof Object && value.toString == null) {\n        stringValue = qx.lang.Json.stringify(value, null, 2);\n      } else {\n        try {\n          stringValue = value.toString();\n        } catch (e) {\n          stringValue = \"\";\n        }\n      }\n      return stringValue;\n    },\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>.\n     *\n     * @param condition {var} Condition to check for. Must evaluate to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assert(condition, msg) {\n      condition == true || this.__fail(msg || \"\", \"Called assert with 'false'\");\n    },\n\n    /**\n     * Raise an {@link AssertionError}.\n     *\n     * @param msg {String} Message to be shown if the assertion fails.\n     * @param compact {Boolean?false} Show less verbose message. Default: false.\n     */\n    fail(msg, compact) {\n      var msgvarargs = compact ? \"\" : \"Called fail().\";\n      this.__fail(msg || \"\", msgvarargs);\n    },\n\n    /**\n     * Assert that the value is <code>true</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertTrue(value, msg) {\n      value === true ||\n        this.__fail(msg || \"\", \"Called assertTrue with '\", value, \"'\");\n    },\n\n    /**\n     * Assert that the value is <code>false</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>false</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFalse(value, msg) {\n      value === false ||\n        this.__fail(msg || \"\", \"Called assertFalse with '\", value, \"'\");\n    },\n\n    /**\n     * Assert that both values are equal. (Uses the equality operator\n     * <code>==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEquals(expected, found, msg) {\n      expected == found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' but found '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are not equal. (Uses the not equality operator\n     * <code>!=</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEquals(expected, found, msg) {\n      expected != found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both float values are equal. This might be needed because\n     * of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEqualsFloat(expected, found, msg) {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      qx.lang.Number.equals(expected, found) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both float values are not equal. This might be needed\n     * because of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEqualsFloat(expected, found, msg) {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      !qx.lang.Number.equals(expected, found) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are identical. (Uses the identity operator\n     * <code>===</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertIdentical(expected, found, msg) {\n      expected === found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' (identical) but found '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are not identical. (Uses the not identity operator\n     * <code>!==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotIdentical(expected, found, msg) {\n      expected !== found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not identical with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value is not <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotUndefined(value, msg) {\n      value !== undefined ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value not to be undefined but found undefined!\"\n        );\n    },\n\n    /**\n     * Assert that the value is <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertUndefined(value, msg) {\n      value === undefined ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be undefined but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is not <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotNull(value, msg) {\n      value !== null ||\n        this.__fail(msg || \"\", \"Expected value not to be null but found null!\");\n    },\n\n    /**\n     * Assert that the value is <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNull(value, msg) {\n      value === null ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be null but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the first two arguments are equal, when serialized into\n     * JSON.\n     *\n     * @param expected {var} The the expected value\n     * @param found {var} The found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertJsonEquals(expected, found, msg) {\n      this.assertEquals(\n        qx.lang.Json.stringify(expected),\n        qx.lang.Json.stringify(found),\n        msg\n      );\n    },\n\n    /**\n     * Assert that the given string matches the regular expression\n     *\n     * @param str {String} String, which should match the regular expression\n     * @param re {String|RegExp} Regular expression to match\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMatch(str, re, msg) {\n      this.assertString(str);\n      this.assert(\n        qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re),\n        \"The parameter 're' must be a string or a regular expression.\"\n      );\n\n      str.search(re) >= 0 ||\n        this.__fail(\n          msg || \"\",\n          \"The String '\",\n          str,\n          \"' does not match the regular expression '\",\n          re.toString(),\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the number of arguments is within the given range\n     *\n     * @param args {arguments} The <code>arguments<code> variable of a function\n     * @param minCount {Integer} Minimal number of arguments\n     * @param maxCount {Integer} Maximum number of arguments\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArgumentsCount(args, minCount, maxCount, msg) {\n      var argCount = args.length;\n      (argCount >= minCount && argCount <= maxCount) ||\n        this.__fail(\n          msg || \"\",\n          \"Wrong number of arguments given. Expected '\",\n          minCount,\n          \"' to '\",\n          maxCount,\n          \"' arguments but found '\",\n          argCount,\n          \"' arguments.\"\n        );\n    },\n\n    /**\n     * Assert that an event is fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   fires the event.\n     * @param listenerFunc {Function?null} The function which will be invoked in the\n     *   listener. The function receives one parameter which is the event.\n     * @param msg {String?\"\"} Message to be shows if the assertion fails.\n     */\n    assertEventFired(obj, event, invokeFunc, listenerFunc, msg) {\n      var called = false;\n      var listener = function (e) {\n        if (listenerFunc) {\n          listenerFunc.call(obj, e);\n        }\n        called = true;\n      };\n\n      var id;\n      try {\n        id = obj.addListener(event, listener, obj);\n        invokeFunc.call(obj);\n      } catch (ex) {\n        throw ex;\n      } finally {\n        try {\n          obj.removeListenerById(id);\n        } catch (ex) {\n          /* ignore */\n        }\n      }\n\n      called === true ||\n        this.__fail(msg || \"\", \"Event (\", event, \") not fired.\");\n    },\n\n    /**\n     * Assert that an event is not fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   should not fire the event.\n     * @param msg {String?} Message to be shows if the assertion fails.\n     */\n    assertEventNotFired(obj, event, invokeFunc, msg) {\n      var called = false;\n      var listener = function (e) {\n        called = true;\n      };\n      var id = obj.addListener(event, listener, obj);\n\n      invokeFunc.call();\n      called === false ||\n        this.__fail(msg || \"\", \"Event (\", event, \") was fired.\");\n\n      obj.removeListenerById(id);\n    },\n\n    /**\n     * Asserts that the callback raises a matching exception.\n     *\n     * @param callback {Function} function to check\n     * @param exception {Error?Error} Expected constructor of the exception.\n     *   The assertion fails if the raised exception is not an instance of the\n     *   parameter.\n     * @param re {String|RegExp} The assertion fails if the error message does\n     *   not match this parameter\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertException(callback, exception, re, msg) {\n      var exception = exception || Error;\n      var error;\n\n      try {\n        this.__logError = false;\n        callback();\n      } catch (ex) {\n        error = ex;\n      } finally {\n        this.__logError = true;\n      }\n\n      if (error == null) {\n        this.__fail(msg || \"\", \"The function did not raise an exception!\");\n      }\n\n      error instanceof exception ||\n        this.__fail(\n          msg || \"\",\n          \"The raised exception does not have the expected type! \",\n          exception,\n          \" != \",\n          error\n        );\n\n      if (re) {\n        this.assertMatch(error.toString(), re, msg);\n      }\n    },\n\n    /**\n     * Assert that the value is an item in the given array.\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInArray(value, array, msg) {\n      array.indexOf(value) !== -1 ||\n        this.__fail(\n          msg || \"\",\n          \"The value '\",\n          value,\n          \"' must have any of the values defined in the array '\",\n          array,\n          \"'\"\n        );\n    },\n\n    /**\n     * Assert that the value is NOT an item in the given array\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of values\n     * @param msg {String?} Message to be shown if the assertion fails\n     */\n    assertNotInArray(value, array, msg) {\n      array.indexOf(value) === -1 ||\n        this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"The value '%1' must not have any of the values defined in the array '%2'\",\n            [value, array]\n          )\n        );\n    },\n\n    /**\n     * Assert that both array have identical array items.\n     *\n     * @param expected {Array} The expected array\n     * @param found {Array} The found array\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArrayEquals(expected, found, msg) {\n      this.assertArray(expected, msg);\n      this.assertArray(found, msg);\n\n      msg =\n        msg ||\n        \"Expected [\" +\n          expected.join(\", \") +\n          \"], but found [\" +\n          found.join(\", \") +\n          \"]\";\n\n      if (expected.length !== found.length) {\n        this.fail(msg, true);\n      }\n\n      for (var i = 0; i < expected.length; i++) {\n        if (expected[i] !== found[i]) {\n          this.fail(msg, true);\n        }\n      }\n    },\n\n    /**\n     * Assert that the value is a key in the given map.\n     *\n     * @param value {var} Value to check\n     * @param map {Map} Map, where the keys represent the valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertKeyInMap(value, map, msg) {\n      map[value] !== undefined ||\n        this.__fail(\n          msg || \"\",\n          \"The value '\",\n          value,\n          \"' must must be a key of the map '\",\n          map,\n          \"'\"\n        );\n    },\n\n    /**\n     * Assert that the value is a function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunction(value, msg) {\n      qx.lang.Type.isFunction(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof function but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a function or an async function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunctionOrAsyncFunction(value, msg) {\n      qx.lang.Type.isFunctionOrAsyncFunction(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof function or typeof async function but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a string.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertString(value, msg) {\n      qx.lang.Type.isString(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a string but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a boolean.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertBoolean(value, msg) {\n      qx.lang.Type.isBoolean(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a boolean but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a number.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNumber(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value)) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a number but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a number >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveNumber(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a number >= 0 but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an integer.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInteger(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an integer but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an integer >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveInteger(value, msg) {\n      var condition =\n        qx.lang.Type.isNumber(value) &&\n        isFinite(value) &&\n        value % 1 === 0 &&\n        value >= 0;\n\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an integer >= 0 but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is inside the given range.\n     *\n     * @param value {var} Value to check\n     * @param min {Number} lower bound\n     * @param max {Number} upper bound\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInRange(value, min, max, msg) {\n      (value >= min && value <= max) ||\n        this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"Expected value '%1' to be in the range '%2'..'%3'!\",\n            [value, min, max]\n          )\n        );\n    },\n\n    /**\n     * Assert that the value is an object.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertObject(value, msg) {\n      var condition =\n        value !== null &&\n        (qx.lang.Type.isObject(value) || typeof value === \"object\");\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof object but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an array.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArray(value, msg) {\n      qx.lang.Type.isArray(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an array but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a map either created using <code>new Object</code>\n     * or by using the object literal notation <code>{ ... }</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMap(value, msg) {\n      qx.lang.Type.isObject(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a map but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a regular expression.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertRegExp(value, msg) {\n      qx.lang.Type.isRegExp(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a regular expression but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value has the given type using the <code>typeof</code>\n     * operator. Because the type is not always what it is supposed to be it is\n     * better to use more explicit checks like {@link #assertString} or\n     * {@link #assertArray}.\n     *\n     * @param value {var} Value to check\n     * @param type {String} expected type of the value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertType(value, type, msg) {\n      this.assertString(type, \"Invalid argument 'type'\");\n\n      typeof value === type ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof '\",\n          type,\n          \"' but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of the given class.\n     *\n     * @param value {var} Value to check\n     * @param clazz {Class} The value must be an instance of this class\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInstance(value, clazz, msg) {\n      var className = clazz.classname || clazz + \"\";\n\n      value instanceof clazz ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be instanceof '\",\n          className,\n          \"' but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value implements the given interface.\n     *\n     * @param value {var} Value to check\n     * @param iface {Class} The value must implement this interface\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInterface(value, iface, msg) {\n      (qx.Class && qx.Class.implementsInterface(value, iface)) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected object '\",\n          value,\n          \"' to implement the interface '\",\n          iface,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value represents the given CSS color value. This method\n     * parses the color strings and compares the RGB values. It is able to\n     * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.\n     *\n     *  @param expected {String} The expected color\n     *  @param value {String} The value to check\n     *  @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertCssColor(expected, value, msg) {\n      var ColorUtil = qx.Class ? qx.Class.getByName(\"qx.util.ColorUtil\") : null;\n      if (!ColorUtil) {\n        throw new Error(\n          \"qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'\"\n        );\n      }\n\n      var expectedRgb = ColorUtil.stringToRgb(expected);\n      try {\n        var valueRgb = ColorUtil.stringToRgb(value);\n      } catch (ex) {\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\",\n          expected,\n          \"' (rgb(\",\n          expectedRgb.join(\",\"),\n          \")), but found value '\",\n          value,\n          \"', which cannot be converted to a CSS color!\"\n        );\n      }\n\n      var condition =\n        expectedRgb[0] == valueRgb[0] &&\n        expectedRgb[1] == valueRgb[1] &&\n        expectedRgb[2] == valueRgb[2];\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\",\n          expectedRgb,\n          \"' (rgb(\",\n          expectedRgb.join(\",\"),\n          \")), but found value '\",\n          value,\n          \"' (rgb(\",\n          valueRgb.join(\",\"),\n          \"))!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a DOM element.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertElement(value, msg) {\n      // see qx.dom.Node.isElement\n      !!(value && value.nodeType === 1) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a DOM element but found  '\",\n          value,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of {@link qx.core.Object}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxObject(value, msg) {\n      this.__isQxInstance(value, \"qx.core.Object\") ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a qooxdoo object but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of {@link qx.ui.core.Widget}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxWidget(value, msg) {\n      this.__isQxInstance(value, \"qx.ui.core.Widget\") ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a qooxdoo widget but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Internal helper for checking the instance of a qooxdoo object using the\n     * classname.\n     *\n     * @param object {var} The object to check.\n     * @param classname {String} The classname of the class as string.\n     * @return {Boolean} <code>true</code> if the object is an instance of the\n     * class\n     */\n    __isQxInstance(object, classname) {\n      if (!object) {\n        return false;\n      }\n      var clazz = object.constructor;\n      while (clazz) {\n        if (clazz.classname === classname) {\n          return true;\n        }\n        clazz = clazz.superclass;\n      }\n      return false;\n    }\n  }\n});\n"
  ]
}