{
  "version": 3,
  "sources": [
    "/home/runner/work/hkollmann.mobilegrid/hkollmann.mobilegrid/node_modules/@qooxdoo/framework/source/class/qx/ui/mobile/container/Scroll.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "mobile",
    "container",
    "Composite",
    "construct",
    "scrollProperties",
    "_scrollProperties",
    "addListener",
    "_updateWaypoints",
    "_waypointsX",
    "_waypointsY",
    "_currentX",
    "_currentY",
    "events",
    "scrollEnd",
    "pageEnd",
    "waypoint",
    "momentumStart",
    "momentumEnd",
    "properties",
    "defaultCssClass",
    "refine",
    "init",
    "delegate",
    "nullable",
    "members",
    "_activeWaypointX",
    "_activeWaypointY",
    "_calculatedWaypointsX",
    "_calculatedWaypointsY",
    "_setCurrentX",
    "value",
    "old",
    "_fireWaypoint",
    "_setCurrentY",
    "setWaypointsX",
    "waypoints",
    "setWaypointsY",
    "getScrollHeight",
    "_getScrollHeight",
    "getScrollWidth",
    "_getScrollWidth",
    "_calcWaypoints",
    "results",
    "scrollSize",
    "axis",
    "offset",
    "i",
    "length",
    "lang",
    "Type",
    "isString",
    "endsWith",
    "parseInt",
    "push",
    "input",
    "index",
    "element",
    "getContentElement",
    "waypointElements",
    "bom",
    "Selector",
    "query",
    "j",
    "position",
    "Location",
    "getRelative",
    "top",
    "scrollTop",
    "left",
    "scrollLeft",
    "isNumber",
    "sort",
    "a",
    "b",
    "nextWaypoint",
    "direction",
    "activeWaypoint",
    "fireDataEvent",
    "_createContainerElement",
    "scrollElement",
    "_createScrollElement",
    "_getContentElement",
    "contentElement",
    "scrollContentElement",
    "_getScrollContentElement",
    "refresh",
    "_refresh",
    "scrollTo",
    "x",
    "y",
    "time",
    "_scrollTo",
    "getPosition",
    "_getPosition",
    "isScrollable",
    "_isScrollable",
    "_isScrollableX",
    "_isScrollableY",
    "getLayoutParent",
    "parentWidth",
    "getContainerElement",
    "clientWidth",
    "contentWidth",
    "scrollWidth",
    "Dimension",
    "getWidth",
    "parentHeight",
    "clientHeight",
    "contentHeight",
    "scrollHeight",
    "getHeight",
    "scrollToElement",
    "target",
    "_scrollToElement",
    "location",
    "_getScrollOffset",
    "getDelegate",
    "getScrollOffset",
    "bind",
    "scrollToWidget",
    "widget",
    "defer",
    "statics",
    "core",
    "Environment",
    "get",
    "include",
    "MIScroll",
    "MNativeScroll",
    "destruct",
    "removeListener",
    "Scroll"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Tino Butz (tbtz)\n\n************************************************************************ */\n\n/**\n * Container, which allows, depending on the set variant <code>qx.mobile.nativescroll</code>,\n * vertical and horizontal scrolling if the contents is larger than the container.\n *\n * Note that this class can only have one child widget. This container has a\n * fixed layout, which cannot be changed.\n *\n * *Example*\n *\n * Here is a little example of how to use the widget.\n *\n * <pre class='javascript'>\n *   // create the scroll widget\n *   var scroll = new qx.ui.mobile.container.Scroll();\n *\n *   // add a children\n *   scroll.add(new qx.ui.mobile.basic.Label(\"Name: \"));\n *\n *   this.getRoot().add(scroll);\n * </pre>\n *\n * This example creates a scroll container and adds a label to it.\n */\nqx.Class.define(\"qx.ui.mobile.container.Scroll\", {\n  extend: qx.ui.mobile.container.Composite,\n\n  /**\n   * @param scrollProperties {Object} A map with scroll properties which are passed to the scrolling container (may contain iScroll properties).\n   */\n  construct(scrollProperties) {\n    super();\n\n    if (scrollProperties) {\n      this._scrollProperties = scrollProperties;\n    }\n\n    this.addListener(\"appear\", this._updateWaypoints, this);\n\n    this._waypointsX = [];\n    this._waypointsY = [];\n\n    this._currentX = 0;\n    this._currentY = 0;\n  },\n\n  events: {\n    /** Fired when the scroll container reaches its end position (including momentum/inertia). */\n    scrollEnd: \"qx.event.type.Event\",\n\n    /** Fired when the user scrolls to the end of scroll area. */\n    pageEnd: \"qx.event.type.Event\",\n\n    /** Fired when a vertical or horizontal waypoint is triggered. Data:\n     * <code> {\"offset\": 0,\n     *        \"input\": \"10%\",\n     *        \"index\": 0,\n     *        \"element\" : 0}</code>\n     */\n    waypoint: \"qx.event.type.Data\",\n\n    /**\n     * Fired when a momentum starts on an iOS device.\n     */\n    momentumStart: \"qx.event.type.Event\",\n\n    /**\n     * Fired when a momentum ends on an iOS device.\n     */\n    momentumEnd: \"qx.event.type.Data\"\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n  properties: {\n    // overridden\n    defaultCssClass: {\n      refine: true,\n      init: \"scroll\"\n    },\n\n    /**\n     * Delegation object which can have one or more functions defined by the\n     * {@link qx.ui.mobile.container.IScrollDelegate} interface.\n     *\n     * @internal\n     */\n    delegate: {\n      init: null,\n      nullable: true\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    _scrollProperties: null,\n    _activeWaypointX: null,\n    _activeWaypointY: null,\n    _waypointsX: null,\n    _waypointsY: null,\n    _calculatedWaypointsX: null,\n    _calculatedWaypointsY: null,\n    _currentX: null,\n    _currentY: null,\n\n    /**\n     * Sets the current x position.\n     * @param value {Number} the current horizontal position.\n     */\n    _setCurrentX(value) {\n      var old = this._currentX;\n      this._currentX = value;\n      this._fireWaypoint(value, old, \"x\");\n    },\n\n    /**\n     * Sets the current y position.\n     * @param value {Number} the current vertical position.\n     */\n    _setCurrentY(value) {\n      var old = this._currentY;\n      this._currentY = value;\n      this._fireWaypoint(value, old, \"y\");\n    },\n\n    /**\n     * Sets the horizontal trigger points, where a <code>waypoint</code> event will be fired.\n     * @param waypoints {Array} description\n     */\n    setWaypointsX(waypoints) {\n      this._waypointsX = waypoints;\n    },\n\n    /**\n     * Sets the vertical trigger points, where a <code>waypoint</code> event will be fired.\n     * @param waypoints {Array} an array with waypoint descriptions. Allowed are percentage description as string, or pixel trigger points defined as numbers. <code>[\"20%\",200]</code>\n     */\n    setWaypointsY(waypoints) {\n      this._waypointsY = waypoints;\n    },\n\n    /**\n     * Returns the scroll height.\n     * @return {Number} the scroll height.\n     */\n    getScrollHeight() {\n      return this._getScrollHeight();\n    },\n\n    /**\n     * Returns the scroll width.\n     * @return {Number} the scroll width.\n     */\n    getScrollWidth() {\n      return this._getScrollWidth();\n    },\n\n    /**\n     * Re-calculates the internal waypoint offsets.\n     */\n    _updateWaypoints() {\n      this._calculatedWaypointsX = [];\n      this._calculatedWaypointsY = [];\n      this._calcWaypoints(\n        this._waypointsX,\n        this._calculatedWaypointsX,\n        this.getScrollWidth(),\n        \"x\"\n      );\n\n      this._calcWaypoints(\n        this._waypointsY,\n        this._calculatedWaypointsY,\n        this.getScrollHeight()\n      );\n    },\n\n    /**\n     * Validates and checks the waypoint offsets.\n     * @param waypoints {Array} an array with waypoint descriptions.\n     * @param results {Array} the array where calculated waypoints will be added.\n     * @param scrollSize {Number} the vertical or horizontal scroll size.\n     * @param axis {String?} \"x\" or \"y\".\n     */\n    _calcWaypoints(waypoints, results, scrollSize, axis) {\n      axis = axis || \"y\";\n\n      var offset = 0;\n      for (var i = 0; i < waypoints.length; i++) {\n        var waypoint = waypoints[i];\n        if (qx.lang.Type.isString(waypoint)) {\n          if (waypoint.endsWith(\"%\")) {\n            offset = parseInt(waypoint, 10) * (scrollSize / 100);\n            results.push({\n              offset: offset,\n              input: waypoint,\n              index: i,\n              element: null,\n              axis: axis\n            });\n          } else {\n            // Dynamically created waypoints, based upon a selector.\n            var element = this.getContentElement();\n            var waypointElements = qx.bom.Selector.query(waypoint, element);\n            for (var j = 0; j < waypointElements.length; j++) {\n              var position = qx.bom.element.Location.getRelative(\n                waypointElements[j],\n                element\n              );\n\n              if (axis === \"y\") {\n                offset = position.top + this.getContentElement().scrollTop;\n              } else if (axis === \"x\") {\n                offset = position.left + this.getContentElement().scrollLeft;\n              }\n              results.push({\n                offset: position.top + this._currentY,\n                input: waypoint,\n                index: i,\n                element: j,\n                axis: axis\n              });\n            }\n          }\n        } else if (qx.lang.Type.isNumber(waypoint)) {\n          results.push({\n            offset: waypoint,\n            input: waypoint,\n            index: i,\n            element: null,\n            axis: axis\n          });\n        }\n      }\n\n      results.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n    },\n\n    /**\n     * Fires a waypoints event when scroll position changes.\n     * @param value {Number} old scroll position.\n     * @param old {Number} old scroll position.\n     * @param axis {String} \"x\" or \"y\".\n     */\n    _fireWaypoint(value, old, axis) {\n      var waypoints = this._calculatedWaypointsY;\n      if (axis === \"x\") {\n        waypoints = this._calculatedWaypointsX;\n      }\n\n      if (waypoints === null) {\n        return;\n      }\n\n      var nextWaypoint = null;\n      for (var i = 0; i < waypoints.length; i++) {\n        var waypoint = waypoints[i];\n        if (waypoint.offset !== null) {\n          if (\n            (value > -1 && value >= waypoint.offset) ||\n            (value < 0 && waypoint.offset < 0 && value <= waypoint.offset)\n          ) {\n            nextWaypoint = waypoint;\n          } else {\n            break;\n          }\n        }\n      }\n\n      if (nextWaypoint === null) {\n        if (axis === \"x\") {\n          this._activeWaypointX = null;\n        } else {\n          this._activeWaypointY = null;\n        }\n        return;\n      }\n\n      var direction = null;\n      if (old <= value) {\n        direction = \"down\";\n        if (axis == \"x\") {\n          direction = \"left\";\n        }\n      } else {\n        direction = \"up\";\n        if (axis == \"x\") {\n          direction = \"right\";\n        }\n      }\n\n      var activeWaypoint = this._activeWaypointY;\n      if (axis === \"x\") {\n        activeWaypoint = this._activeWaypointX;\n      }\n\n      if (\n        activeWaypoint === null ||\n        activeWaypoint.index !== nextWaypoint.index ||\n        activeWaypoint.element !== nextWaypoint.element\n      ) {\n        activeWaypoint = nextWaypoint;\n        this._activeWaypointY = activeWaypoint;\n        if (axis === \"x\") {\n          this._activeWaypointX = activeWaypoint;\n        }\n        this.fireDataEvent(\"waypoint\", {\n          axis: axis,\n          index: nextWaypoint.index,\n          element: nextWaypoint.element,\n          direction: direction\n        });\n      }\n    },\n\n    // overridden\n    _createContainerElement() {\n      var element = super._createContainerElement();\n      var scrollElement = this._createScrollElement();\n      if (scrollElement) {\n        return scrollElement;\n      }\n\n      return element;\n    },\n\n    // overridden\n    _getContentElement() {\n      var contentElement = super._getContentElement();\n\n      var scrollContentElement = this._getScrollContentElement();\n\n      return scrollContentElement || contentElement;\n    },\n\n    /**\n     * Calls the refresh function the used scrolling method. Needed to recalculate the\n     * scrolling container.\n     */\n    refresh() {\n      this._refresh();\n      this._updateWaypoints();\n    },\n\n    /**\n     * Scrolls the wrapper contents to the x/y coordinates in a given time.\n     *\n     * @param x {Integer} X coordinate to scroll to.\n     * @param y {Integer} Y coordinate to scroll to.\n     * @param time {Integer} Time slice in which scrolling should\n     *              be done.\n     */\n    scrollTo(x, y, time) {\n      this._scrollTo(x, y, time);\n    },\n\n    /**\n     * Returns the current scroll position\n     * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.\n     */\n    getPosition() {\n      return this._getPosition();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    isScrollable() {\n      return this._isScrollable();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollable() {\n      return this._isScrollableX() || this._isScrollableY();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable on x axis or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollableX() {\n      if (this.getLayoutParent() === null) {\n        return false;\n      }\n\n      var parentWidth = this.getContainerElement().clientWidth;\n      var contentWidth = this.getContentElement().scrollWidth;\n\n      var scrollContentElement = this._getScrollContentElement();\n      if (scrollContentElement) {\n        contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);\n      }\n\n      return parentWidth < contentWidth;\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable on y axis or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollableY() {\n      if (this.getLayoutParent() === null) {\n        return false;\n      }\n\n      var parentHeight = this.getContainerElement().clientHeight;\n      var contentHeight = this.getContentElement().scrollHeight;\n\n      var scrollContentElement = this._getScrollContentElement();\n      if (scrollContentElement) {\n        contentHeight =\n          qx.bom.element.Dimension.getHeight(scrollContentElement);\n      }\n\n      return parentHeight < contentHeight;\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param target {Element} the element to which the scroll container should scroll to.\n     * @param time {Integer?0} Time slice in which scrolling should\n     *              be done (in seconds).\n     *\n     */\n    scrollToElement(target, time) {\n      this._scrollToElement(target, time);\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param element {String} the element to which the scroll container should scroll to.\n     * @param time {Integer?0} Time slice in which scrolling should be done (in seconds).\n     *\n     */\n    _scrollToElement(element, time) {\n      if (this._getContentElement() && this._isScrollable()) {\n        if (typeof time === \"undefined\") {\n          time = 0;\n        }\n\n        var location = qx.bom.element.Location.getRelative(\n          this._getContentElement(),\n          element,\n          \"scroll\",\n          \"scroll\"\n        );\n\n        var offset = this._getScrollOffset();\n\n        this._scrollTo(\n          -location.left - offset[0],\n          -location.top - offset[1],\n          time\n        );\n      }\n    },\n\n    /**\n     *\n     * Determines the scroll offset for the <code>_scrollToElement</code> method.\n     * If a delegate is available, the method calls\n     * <code>qx.ui.mobile.container.IScrollDelegate.getScrollOffset()</code> for offset calculation.\n     *\n     * @return {Array} an array with x,y offset.\n     */\n    _getScrollOffset() {\n      var delegate = this.getDelegate();\n      if (delegate != null && delegate.getScrollOffset) {\n        return delegate.getScrollOffset.bind(this)();\n      } else {\n        return [0, 0];\n      }\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param widget {qx.ui.mobile.core.Widget} the widget, the scroll container should scroll to.\n     * @param time {Integer} Time slice in which scrolling should\n     *              be done.\n     */\n    scrollToWidget(widget, time) {\n      if (widget) {\n        this._scrollToElement(widget.getContentElement(), time);\n      }\n    }\n  },\n\n  defer(statics) {\n    if (qx.core.Environment.get(\"qx.mobile.nativescroll\") == false) {\n      qx.Class.include(statics, qx.ui.mobile.container.MIScroll);\n    } else {\n      qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);\n    }\n  },\n\n  destruct() {\n    this.removeListener(\"appear\", this._updateWaypoints, this);\n    this._waypointsX = this._waypointsY = null;\n  }\n});\n"
  ]
}