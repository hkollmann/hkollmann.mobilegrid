{
  "version": 3,
  "sources": [
    "/home/runner/work/hkollmann.mobilegrid/hkollmann.mobilegrid/node_modules/@qooxdoo/framework/source/class/qx/ui/table/selection/Model.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "__selectedRangeArr",
    "__anchorSelectionIndex",
    "__leadSelectionIndex",
    "hasBatchModeRefCount",
    "__hadChangeEventInBatchMode",
    "events",
    "changeSelection",
    "statics",
    "NO_SELECTION",
    "SINGLE_SELECTION",
    "SINGLE_INTERVAL_SELECTION",
    "MULTIPLE_INTERVAL_SELECTION",
    "MULTIPLE_INTERVAL_SELECTION_TOGGLE",
    "properties",
    "selectionMode",
    "init",
    "check",
    "apply",
    "members",
    "_applySelectionMode",
    "resetSelection",
    "setBatchMode",
    "batchMode",
    "Error",
    "_fireChangeSelection",
    "hasBatchMode",
    "getAnchorSelectionIndex",
    "_setAnchorSelectionIndex",
    "index",
    "getLeadSelectionIndex",
    "_setLeadSelectionIndex",
    "_getSelectedRangeArr",
    "isSelectionEmpty",
    "_resetSelection",
    "length",
    "getSelectedCount",
    "selectedCount",
    "i",
    "range",
    "maxIndex",
    "minIndex",
    "isSelectedIndex",
    "getSelectedRanges",
    "retVal",
    "push",
    "iterateSelection",
    "iterator",
    "object",
    "j",
    "call",
    "setSelectionInterval",
    "fromIndex",
    "toIndex",
    "me",
    "getSelectionMode",
    "_addSelectionInterval",
    "removeSelectionInterval",
    "e",
    "addSelectionInterval",
    "SelectionModel",
    "ui",
    "table",
    "selection",
    "Model",
    "rowsRemoved",
    "Math",
    "min",
    "max",
    "removeCount",
    "newRanges",
    "extraRange",
    "minIsIn",
    "maxIsIn",
    "newRangeIndex",
    "splice",
    "lastRange",
    "_dumpRanges",
    "text",
    "debug",
    "fireEvent",
    "destruct"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Til Schneider (til132)\n     * David Perez Carmona (david-perez)\n\n************************************************************************ */\n\n/**\n * A selection model.\n */\nqx.Class.define(\"qx.ui.table.selection.Model\", {\n  extend: qx.core.Object,\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct() {\n    super();\n\n    this.__selectedRangeArr = [];\n    this.__anchorSelectionIndex = -1;\n    this.__leadSelectionIndex = -1;\n    this.hasBatchModeRefCount = 0;\n    this.__hadChangeEventInBatchMode = false;\n  },\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events: {\n    /** Fired when the selection has changed. */\n    changeSelection: \"qx.event.type.Event\"\n  },\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics: {\n    /** @type {int} The selection mode \"none\". Nothing can ever be selected. */\n    NO_SELECTION: 1,\n\n    /** @type {int} The selection mode \"single\". This mode only allows one selected item. */\n    SINGLE_SELECTION: 2,\n\n    /**\n     * @type {int} The selection mode \"single interval\". This mode only allows one\n     * continuous interval of selected items.\n     */\n    SINGLE_INTERVAL_SELECTION: 3,\n\n    /**\n     * @type {int} The selection mode \"multiple interval\". This mode only allows any\n     * selection.\n     */\n    MULTIPLE_INTERVAL_SELECTION: 4,\n\n    /**\n     * @type {int} The selection mode \"multiple interval\". This mode only allows any\n     * selection. The difference with the previous one, is that multiple\n     * selection is eased. A tap on an item, toggles its selection state.\n     * On the other hand, MULTIPLE_INTERVAL_SELECTION does this behavior only\n     * when Ctrl-tapping an item.\n     */\n    MULTIPLE_INTERVAL_SELECTION_TOGGLE: 5\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties: {\n    /**\n     * Set the selection mode. Valid values are {@link #NO_SELECTION},\n     * {@link #SINGLE_SELECTION}, {@link #SINGLE_INTERVAL_SELECTION},\n     * {@link #MULTIPLE_INTERVAL_SELECTION} and\n     * {@link #MULTIPLE_INTERVAL_SELECTION_TOGGLE}.\n     */\n    selectionMode: {\n      init: 2, //SINGLE_SELECTION,\n      check: [1, 2, 3, 4, 5],\n      //[ NO_SELECTION, SINGLE_SELECTION, SINGLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION_TOGGLE ],\n      apply: \"_applySelectionMode\"\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    __hadChangeEventInBatchMode: null,\n    __anchorSelectionIndex: null,\n    __leadSelectionIndex: null,\n    __selectedRangeArr: null,\n\n    // selectionMode property modifier\n    _applySelectionMode(selectionMode) {\n      this.resetSelection();\n    },\n\n    /**\n     *\n     * Activates / Deactivates batch mode. In batch mode, no change events will be thrown but\n     * will be collected instead. When batch mode is turned off again and any events have\n     * been collected, one event is thrown to inform the listeners.\n     *\n     * This method supports nested calling, i. e. batch mode can be turned more than once.\n     * In this case, batch mode will not end until it has been turned off once for each\n     * turning on.\n     *\n     * @param batchMode {Boolean} true to activate batch mode, false to deactivate\n     * @return {Boolean} true if batch mode is active, false otherwise\n     * @throws {Error} if batch mode is turned off once more than it has been turned on\n     */\n    setBatchMode(batchMode) {\n      if (batchMode) {\n        this.hasBatchModeRefCount += 1;\n      } else {\n        if (this.hasBatchModeRefCount == 0) {\n          throw new Error(\n            \"Try to turn off batch mode althoug it was not turned on.\"\n          );\n        }\n\n        this.hasBatchModeRefCount -= 1;\n\n        if (this.__hadChangeEventInBatchMode) {\n          this.__hadChangeEventInBatchMode = false;\n          this._fireChangeSelection();\n        }\n      }\n\n      return this.hasBatchMode();\n    },\n\n    /**\n     *\n     * Returns whether batch mode is active. See setter for a description of batch mode.\n     *\n     * @return {Boolean} true if batch mode is active, false otherwise\n     */\n    hasBatchMode() {\n      return this.hasBatchModeRefCount > 0;\n    },\n\n    /**\n     * Returns the first argument of the last call to {@link #setSelectionInterval()},\n     * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.\n     *\n     * @return {Integer} the anchor selection index.\n     */\n    getAnchorSelectionIndex() {\n      return this.__anchorSelectionIndex;\n    },\n\n    /**\n     * Sets the anchor selection index. Only use this function, if you want manipulate\n     * the selection manually.\n     *\n     * @param index {Integer} the index to set.\n     */\n    _setAnchorSelectionIndex(index) {\n      this.__anchorSelectionIndex = index;\n    },\n\n    /**\n     * Returns the second argument of the last call to {@link #setSelectionInterval()},\n     * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.\n     *\n     * @return {Integer} the lead selection index.\n     */\n    getLeadSelectionIndex() {\n      return this.__leadSelectionIndex;\n    },\n\n    /**\n     * Sets the lead selection index. Only use this function, if you want manipulate\n     * the selection manually.\n     *\n     * @param index {Integer} the index to set.\n     */\n    _setLeadSelectionIndex(index) {\n      this.__leadSelectionIndex = index;\n    },\n\n    /**\n     * Returns an array that holds all the selected ranges of the table. Each\n     * entry is a map holding information about the \"minIndex\" and \"maxIndex\" of the\n     * selection range.\n     *\n     * @return {Map[]} array with all the selected ranges.\n     */\n    _getSelectedRangeArr() {\n      return this.__selectedRangeArr;\n    },\n\n    /**\n     * Resets (clears) the selection.\n     */\n    resetSelection() {\n      if (!this.isSelectionEmpty()) {\n        this._resetSelection();\n        this._fireChangeSelection();\n      }\n    },\n\n    /**\n     * Returns whether the selection is empty.\n     *\n     * @return {Boolean} whether the selection is empty.\n     */\n    isSelectionEmpty() {\n      return this.__selectedRangeArr.length == 0;\n    },\n\n    /**\n     * Returns the number of selected items.\n     *\n     * @return {Integer} the number of selected items.\n     */\n    getSelectedCount() {\n      var selectedCount = 0;\n\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\n        var range = this.__selectedRangeArr[i];\n        selectedCount += range.maxIndex - range.minIndex + 1;\n      }\n\n      return selectedCount;\n    },\n\n    /**\n     * Returns whether an index is selected.\n     *\n     * @param index {Integer} the index to check.\n     * @return {Boolean} whether the index is selected.\n     */\n    isSelectedIndex(index) {\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\n        var range = this.__selectedRangeArr[i];\n\n        if (index >= range.minIndex && index <= range.maxIndex) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Returns the selected ranges as an array. Each array element has a\n     * <code>minIndex</code> and a <code>maxIndex</code> property.\n     *\n     * @return {Map[]} the selected ranges.\n     */\n    getSelectedRanges() {\n      // clone the selection array and the individual elements - this prevents the\n      // caller from messing with the internal model\n      var retVal = [];\n\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\n        retVal.push({\n          minIndex: this.__selectedRangeArr[i].minIndex,\n          maxIndex: this.__selectedRangeArr[i].maxIndex\n        });\n      }\n\n      return retVal;\n    },\n\n    /**\n     * Calls an iterator function for each selected index.\n     *\n     * Usage Example:\n     * <pre class='javascript'>\n     * var selectedRowData = [];\n     * mySelectionModel.iterateSelection(function(index) {\n     *   selectedRowData.push(myTableModel.getRowData(index));\n     * });\n     * </pre>\n     *\n     * @param iterator {Function} the function to call for each selected index.\n     *          Gets the current index as parameter.\n     * @param object {var ? null} the object to use when calling the handler.\n     *          (this object will be available via \"this\" in the iterator)\n     */\n    iterateSelection(iterator, object) {\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\n        for (\n          var j = this.__selectedRangeArr[i].minIndex;\n          j <= this.__selectedRangeArr[i].maxIndex;\n          j++\n        ) {\n          iterator.call(object, j);\n        }\n      }\n    },\n\n    /**\n     * Sets the selected interval. This will clear the former selection.\n     *\n     * @param fromIndex {Integer} the first index of the selection (including).\n     * @param toIndex {Integer} the last index of the selection (including).\n     */\n    setSelectionInterval(fromIndex, toIndex) {\n      var me = this.self(arguments);\n\n      switch (this.getSelectionMode()) {\n        case me.NO_SELECTION:\n          return;\n\n        case me.SINGLE_SELECTION:\n          // Ensure there is actually a change of selection\n          if (this.isSelectedIndex(toIndex)) {\n            return;\n          }\n\n          fromIndex = toIndex;\n          break;\n\n        case me.MULTIPLE_INTERVAL_SELECTION_TOGGLE:\n          this.setBatchMode(true);\n          try {\n            for (var i = fromIndex; i <= toIndex; i++) {\n              if (!this.isSelectedIndex(i)) {\n                this._addSelectionInterval(i, i);\n              } else {\n                this.removeSelectionInterval(i, i);\n              }\n            }\n          } catch (e) {\n            throw e;\n          } finally {\n            this.setBatchMode(false);\n          }\n          this._fireChangeSelection();\n          return;\n      }\n\n      this._resetSelection();\n      this._addSelectionInterval(fromIndex, toIndex);\n\n      this._fireChangeSelection();\n    },\n\n    /**\n     * Adds a selection interval to the current selection.\n     *\n     * @param fromIndex {Integer} the first index of the selection (including).\n     * @param toIndex {Integer} the last index of the selection (including).\n     */\n    addSelectionInterval(fromIndex, toIndex) {\n      var SelectionModel = qx.ui.table.selection.Model;\n\n      switch (this.getSelectionMode()) {\n        case SelectionModel.NO_SELECTION:\n          return;\n\n        case SelectionModel.MULTIPLE_INTERVAL_SELECTION:\n        case SelectionModel.MULTIPLE_INTERVAL_SELECTION_TOGGLE:\n          this._addSelectionInterval(fromIndex, toIndex);\n          this._fireChangeSelection();\n          break;\n\n        default:\n          this.setSelectionInterval(fromIndex, toIndex);\n          break;\n      }\n    },\n\n    /**\n     * Removes an interval from the current selection.\n     *\n     * @param fromIndex {Integer} the first index of the interval (including).\n     * @param toIndex {Integer} the last index of the interval (including).\n     * @param rowsRemoved {Boolean?} rows were removed that caused this selection to change.\n     *   If rows were removed, move the selections over so the same rows are selected as before.\n     */\n    removeSelectionInterval(fromIndex, toIndex, rowsRemoved) {\n      this.__anchorSelectionIndex = fromIndex;\n      this.__leadSelectionIndex = toIndex;\n\n      var minIndex = Math.min(fromIndex, toIndex);\n      var maxIndex = Math.max(fromIndex, toIndex);\n      var removeCount = maxIndex + 1 - minIndex;\n\n      // Crop the affected ranges\n      var newRanges = [];\n      var extraRange = null;\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\n        var range = this.__selectedRangeArr[i];\n\n        if (range.minIndex > maxIndex) {\n          if (rowsRemoved) {\n            // Move whole selection up.\n            range.minIndex -= removeCount;\n            range.maxIndex -= removeCount;\n          }\n        } else if (range.maxIndex >= minIndex) {\n          // This range is affected\n          var minIsIn = range.minIndex >= minIndex;\n          var maxIsIn =\n            range.maxIndex >= minIndex && range.maxIndex <= maxIndex;\n\n          if (minIsIn && maxIsIn) {\n            // This range is removed completely\n            range = null;\n          } else if (minIsIn) {\n            if (rowsRemoved) {\n              range.minIndex = minIndex;\n              range.maxIndex -= removeCount;\n            } else {\n              // The range is cropped from the left\n              range.minIndex = maxIndex + 1;\n            }\n          } else if (maxIsIn) {\n            // The range is cropped from the right\n            range.maxIndex = minIndex - 1;\n          } else {\n            if (rowsRemoved) {\n              range.maxIndex -= removeCount;\n            } else {\n              // The range is split\n              extraRange = {\n                minIndex: maxIndex + 1,\n                maxIndex: range.maxIndex\n              };\n\n              range.maxIndex = minIndex - 1;\n            }\n          }\n        }\n\n        if (range) {\n          newRanges.push(range);\n          range = null;\n        }\n        if (extraRange) {\n          newRanges.push(extraRange);\n          extraRange = null;\n        }\n      }\n\n      this.__selectedRangeArr = newRanges;\n\n      this._fireChangeSelection();\n    },\n\n    /**\n     * Resets (clears) the selection, but doesn't inform the listeners.\n     */\n    _resetSelection() {\n      this.__selectedRangeArr = [];\n      this.__anchorSelectionIndex = -1;\n      this.__leadSelectionIndex = -1;\n    },\n\n    /**\n     * Adds a selection interval to the current selection, but doesn't inform\n     * the listeners.\n     *\n     * @param fromIndex {Integer} the first index of the selection (including).\n     * @param toIndex {Integer} the last index of the selection (including).\n     */\n    _addSelectionInterval(fromIndex, toIndex) {\n      this.__anchorSelectionIndex = fromIndex;\n      this.__leadSelectionIndex = toIndex;\n\n      var minIndex = Math.min(fromIndex, toIndex);\n      var maxIndex = Math.max(fromIndex, toIndex);\n\n      // Find the index where the new range should be inserted\n      var newRangeIndex = 0;\n\n      for (; newRangeIndex < this.__selectedRangeArr.length; newRangeIndex++) {\n        var range = this.__selectedRangeArr[newRangeIndex];\n\n        if (range.minIndex > minIndex) {\n          break;\n        }\n      }\n\n      // Add the new range\n      this.__selectedRangeArr.splice(newRangeIndex, 0, {\n        minIndex: minIndex,\n        maxIndex: maxIndex\n      });\n\n      // Merge overlapping ranges\n      var lastRange = this.__selectedRangeArr[0];\n\n      for (var i = 1; i < this.__selectedRangeArr.length; i++) {\n        var range = this.__selectedRangeArr[i];\n\n        if (lastRange.maxIndex + 1 >= range.minIndex) {\n          // The ranges are overlapping -> merge them\n          lastRange.maxIndex = Math.max(lastRange.maxIndex, range.maxIndex);\n\n          // Remove the current range\n          this.__selectedRangeArr.splice(i, 1);\n\n          // Check this index another time\n          i--;\n        } else {\n          lastRange = range;\n        }\n      }\n    },\n\n    // this._dumpRanges();\n    /**\n     * Logs the current ranges for debug purposes.\n     *\n     */\n    _dumpRanges() {\n      var text = \"Ranges:\";\n\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\n        var range = this.__selectedRangeArr[i];\n        text += \" [\" + range.minIndex + \"..\" + range.maxIndex + \"]\";\n      }\n\n      this.debug(text);\n    },\n\n    /**\n     * Fires the \"changeSelection\" event to all registered listeners. If the selection model\n     * currently is in batch mode, only one event will be thrown when batch mode is ended.\n     *\n     */\n    _fireChangeSelection() {\n      if (this.hasBatchMode()) {\n        // In batch mode, remember event but do not throw (yet)\n        this.__hadChangeEventInBatchMode = true;\n      } else {\n        // If not in batch mode, throw event\n        this.fireEvent(\"changeSelection\");\n      }\n    }\n  },\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n  destruct() {\n    this.__selectedRangeArr = null;\n  }\n});\n"
  ]
}